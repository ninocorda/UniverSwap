{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Create2} from \"../utils/Create2.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    error CloneArgumentsTooLong();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\n     * the clones cannot be deployed twice at the same address.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create opcode, which should never revert.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\n        return cloneWithImmutableArgs(implementation, args, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\n     * parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\n     * at the same address.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\n     * but with a `value` parameter to send native currency to the new contract.\n     *\n     * WARNING: This function does not check if `implementation` has code. A clone that points to an address\n     * without code cannot be initialized. Initialization calls may appear to be successful when, in reality, they\n     * have no effect and leave the clone uninitialized, allowing a third party to initialize it later.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }\n\n    /**\n     * @dev Get the immutable args attached to a clone.\n     *\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\n     *   function will return an empty array.\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\n     *   creation.\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\n     *   function should only be used to check addresses that are known to be clones.\n     */\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }\n\n    /**\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\n     *\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\n     * abi.encodePacked is more expensive but also more portable and easier to review.\n     *\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\n     */\n    function _cloneCodeWithImmutableArgs(\n        address implementation,\n        bytes memory args\n    ) private pure returns (bytes memory) {\n        if (args.length > 24531) revert CloneArgumentsTooLong();\n        return\n            abi.encodePacked(\n                hex\"61\",\n                uint16(args.length + 45),\n                hex\"3d81600a3d39f3363d3d373d3d3d363d73\",\n                implementation,\n                hex\"5af43d82803e903d91602b57fd5bf3\",\n                args\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "contracts/interfaces/IERC20Template.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IERC20Template {\n    enum FeeType { Treasury, Burn, Liquidity, Staking }\n\n    struct FeeSplit {\n        FeeType feeType;\n        uint16 bps;\n        address recipient;\n    }\n\n    struct AntiWhaleConfig {\n        bool enabled;\n        uint256 maxTxAmount;\n        uint256 maxWalletAmount;\n        uint8 cooldownBlocks;\n    }\n\n    struct InitRecipient {\n        address account;\n        uint256 amount;\n        bool vesting;\n        uint64 vestingStart;\n        uint64 cliff;\n        uint64 duration;\n        bool revocable;\n    }\n\n    struct TokenConfig {\n        uint256 initialSupply;\n        uint256 cap;\n        bool mintable;\n        bool burnable;\n        bool pausable;\n        bool governanceEnabled;\n        bool autoLiquidityEnabled;\n        bool antiWhaleEnabled;\n        bool stakingEnabled;\n        uint16 autoLiquidityBps;\n        address autoLiquidityRouter;\n        address autoLiquidityPairToken;\n        address stakingManager;\n        string metadataURI;\n        string brandingURI;\n        FeeSplit[] fees;\n        InitRecipient[] initialDistribution;\n        address[] minters;\n        address[] pausers;\n        address[] burners;\n        address[] bridgeOperators;\n        AntiWhaleConfig antiWhale;\n    }\n\n    struct TokenInit {\n        string name;\n        string symbol;\n        uint8 decimals;\n        address owner;\n        uint8 tierId;\n        uint64 templateVersion;\n    }\n\n    function initialize(TokenInit memory init_, TokenConfig calldata cfg_) external;\n}\n"
    },
    "contracts/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IERC20Template } from \"./interfaces/IERC20Template.sol\";\n\n/// @title TokenFactory deploying standalone ERC20 templates with tiered premium features\ncontract TokenFactory is Ownable {\n    // --------------------------------------------------\n    // Feature bitmask\n    // --------------------------------------------------\n    uint256 private constant FEATURE_CAP = 1 << 0;\n    uint256 private constant FEATURE_ROLES = 1 << 1;\n    uint256 private constant FEATURE_DISTRIBUTION = 1 << 2;\n    uint256 private constant FEATURE_METADATA = 1 << 3;\n    uint256 private constant FEATURE_FEES = 1 << 4;\n    uint256 private constant FEATURE_AUTO_LIQUIDITY = 1 << 5;\n    uint256 private constant FEATURE_ANTI_WHALE = 1 << 6;\n    uint256 private constant FEATURE_STAKING = 1 << 7;\n    uint256 private constant FEATURE_VESTING = 1 << 8;\n    uint256 private constant FEATURE_GOVERNANCE = 1 << 9;\n    uint256 private constant FEATURE_BRIDGE = 1 << 10;\n    uint256 private constant FEATURE_BRANDING = 1 << 11;\n\n    uint8 public constant TIER_BASIC = 1;\n    uint8 public constant TIER_ADVANCED = 2;\n    uint8 public constant TIER_PRO = 3;\n    uint8 public constant TIER_DAO = 4;\n    uint8 public constant TIER_PREMIUM = 5;\n\n    uint256 private constant BNB_DECIMALS = 1e18;\n    uint16 private constant BPS_DENOMINATOR = 10_000;\n\n    struct TierInfo {\n        uint256 price; // in wei\n        uint256 features;\n    }\n\n    struct TokenRecord {\n        address creator;\n        uint8 tierId;\n        uint64 createdAt;\n        bytes32 configHash;\n    }\n\n    address payable public feeRecipient;\n    address public templateImplementation;\n\n    mapping(uint8 => TierInfo) public tierInfo;\n    address[] public allTokens;\n    mapping(address => TokenRecord) public tokenRecords;\n\n    event TokenCreatedExtended(\n        address indexed token,\n        address indexed creator,\n        uint8 indexed tierId,\n        string name,\n        string symbol,\n        bytes32 configHash,\n        string metadataURI,\n        string brandingURI\n    );\n\n    event TierUpdated(uint8 indexed tierId, uint256 price, uint256 features);\n    event FeeRecipientUpdated(address indexed newRecipient);\n    event Withdraw(address indexed to, uint256 amount);\n\n    constructor(address template_) Ownable(msg.sender) {\n        feeRecipient = payable(msg.sender);\n        _setTemplate(template_);\n\n        _setTier(TIER_BASIC, 0.01 ether, 0);\n        _setTier(TIER_ADVANCED, 0.015 ether, FEATURE_CAP | FEATURE_ROLES | FEATURE_DISTRIBUTION | FEATURE_METADATA);\n        _setTier(\n            TIER_PRO,\n            0.025 ether,\n            FEATURE_CAP | FEATURE_ROLES | FEATURE_DISTRIBUTION | FEATURE_METADATA |\n                FEATURE_FEES | FEATURE_AUTO_LIQUIDITY | FEATURE_ANTI_WHALE | FEATURE_STAKING | FEATURE_VESTING\n        );\n        _setTier(\n            TIER_DAO,\n            0.035 ether,\n            FEATURE_CAP | FEATURE_ROLES | FEATURE_DISTRIBUTION | FEATURE_METADATA |\n                FEATURE_FEES | FEATURE_AUTO_LIQUIDITY | FEATURE_ANTI_WHALE | FEATURE_STAKING | FEATURE_VESTING |\n                FEATURE_GOVERNANCE | FEATURE_BRIDGE\n        );\n        _setTier(\n            TIER_PREMIUM,\n            0.04 ether,\n            FEATURE_CAP | FEATURE_ROLES | FEATURE_DISTRIBUTION | FEATURE_METADATA |\n                FEATURE_FEES | FEATURE_AUTO_LIQUIDITY | FEATURE_ANTI_WHALE | FEATURE_STAKING | FEATURE_VESTING |\n                FEATURE_GOVERNANCE | FEATURE_BRIDGE | FEATURE_BRANDING\n        );\n    }\n\n    // --------------------------------------------------\n    // External admin\n    // --------------------------------------------------\n    function setTier(uint8 tierId, uint256 price, uint256 features) external onlyOwner {\n        require(tierId >= TIER_BASIC && tierId <= TIER_PREMIUM, \"TIER_RANGE\");\n        require(price > 0, \"PRICE_ZERO\");\n        _setTier(tierId, price, features);\n    }\n\n    function setTemplateImplementation(address template_) external onlyOwner {\n        _setTemplate(template_);\n    }\n\n    function setFeeRecipient(address payable newRecipient) external onlyOwner {\n        require(newRecipient != address(0), \"RECIPIENT_ZERO\");\n        feeRecipient = newRecipient;\n        emit FeeRecipientUpdated(newRecipient);\n    }\n\n    function withdraw(address payable to, uint256 amount) external onlyOwner {\n        require(to != address(0), \"WITHDRAW_ZERO\");\n        require(amount <= address(this).balance, \"BALANCE_LOW\");\n        to.transfer(amount);\n        emit Withdraw(to, amount);\n    }\n\n    // --------------------------------------------------\n    // Public view helpers\n    // --------------------------------------------------\n    function totalTokens() external view returns (uint256) {\n        return allTokens.length;\n    }\n\n    // --------------------------------------------------\n    // Core creation flow\n    // --------------------------------------------------\n    function createToken(\n        uint8 tierId,\n        IERC20Template.TokenInit memory init,\n        IERC20Template.TokenConfig calldata cfg\n    ) external payable returns (address token) {\n        TierInfo memory tier = tierInfo[tierId];\n        require(tier.price > 0, \"TIER_UNKNOWN\");\n\n        require(msg.value >= tier.price, \"PRICE_INSUFFICIENT\");\n\n        init.owner = msg.sender;\n        init.tierId = tierId;\n        init.templateVersion = 0; // let template assign current\n\n        _validateConfig(tier.features, init.owner, tierId, cfg);\n\n        address proxy = Clones.clone(templateImplementation);\n        IERC20Template tokenInstance = IERC20Template(proxy);\n        tokenInstance.initialize(init, cfg);\n        token = proxy;\n\n        bytes32 cfgHash = keccak256(abi.encode(cfg));\n        tokenRecords[token] = TokenRecord({\n            creator: msg.sender,\n            tierId: tierId,\n            createdAt: uint64(block.timestamp),\n            configHash: cfgHash\n        });\n        allTokens.push(token);\n\n        emit TokenCreatedExtended(token, msg.sender, tierId, init.name, init.symbol, cfgHash, cfg.metadataURI, cfg.brandingURI);\n\n        address payable recipient = feeRecipient != address(0) ? feeRecipient : payable(owner());\n        (bool feeSent, ) = recipient.call{value: tier.price}(\"\");\n        require(feeSent, \"FEE_TRANSFER_FAILED\");\n\n        if (msg.value > tier.price) {\n            unchecked {\n                payable(msg.sender).transfer(msg.value - tier.price);\n            }\n        }\n    }\n\n    // --------------------------------------------------\n    // Internal helpers\n    // --------------------------------------------------\n    function _setTier(uint8 tierId, uint256 price, uint256 features) private {\n        tierInfo[tierId] = TierInfo({ price: price, features: features });\n        emit TierUpdated(tierId, price, features);\n    }\n\n    function _setTemplate(address template_) private {\n        require(template_ != address(0), \"TEMPLATE_ZERO\");\n        templateImplementation = template_;\n    }\n\n    function _validateConfig(\n        uint256 tierFeatures,\n        address owner,\n        uint8 tierId,\n        IERC20Template.TokenConfig calldata cfg\n    ) private pure {\n        require(cfg.initialDistribution.length > 0 || cfg.initialSupply == 0, \"DIST_REQUIRED\");\n\n        uint256 requiredFeatures;\n\n        if (cfg.cap > 0) {\n            _assertFeature(tierFeatures, FEATURE_CAP, tierId, \"CAP_FORBIDDEN\");\n            requiredFeatures |= FEATURE_CAP;\n            require(cfg.cap >= cfg.initialSupply, \"CAP_LT_SUPPLY\");\n        }\n\n        if (cfg.minters.length > 0 || cfg.pausers.length > 0 || cfg.burners.length > 0 || cfg.bridgeOperators.length > 0) {\n            _assertFeature(tierFeatures, FEATURE_ROLES, tierId, \"ROLES_FORBIDDEN\");\n            requiredFeatures |= FEATURE_ROLES;\n        }\n\n        // Distribution checks\n        uint256 totalDistribution;\n        bool hasVesting;\n        bool nonOwnerRecipient;\n        for (uint256 i = 0; i < cfg.initialDistribution.length; i++) {\n            IERC20Template.InitRecipient calldata dist = cfg.initialDistribution[i];\n            totalDistribution += dist.amount;\n            if (dist.vesting) {\n                hasVesting = true;\n            }\n            if (dist.account != owner) {\n                nonOwnerRecipient = true;\n            }\n        }\n\n        if (cfg.initialDistribution.length > 1 || nonOwnerRecipient || hasVesting) {\n            requiredFeatures |= FEATURE_DISTRIBUTION;\n            _assertFeature(tierFeatures, FEATURE_DISTRIBUTION, tierId, \"DIST_FORBIDDEN\");\n        } else {\n            IERC20Template.InitRecipient calldata onlyDist = cfg.initialDistribution[0];\n            require(!onlyDist.vesting, \"VESTING_BASIC\");\n            require(onlyDist.account == owner, \"BASIC_OWNER_DIST\");\n        }\n\n        if (bytes(cfg.metadataURI).length > 0) {\n            requiredFeatures |= FEATURE_METADATA;\n            _assertFeature(tierFeatures, FEATURE_METADATA, tierId, \"META_FORBIDDEN\");\n        }\n        if (bytes(cfg.brandingURI).length > 0) {\n            requiredFeatures |= FEATURE_BRANDING;\n            _assertFeature(tierFeatures, FEATURE_BRANDING, tierId, \"BRANDING_FORBIDDEN\");\n        }\n\n        if (cfg.fees.length > 0 || cfg.stakingEnabled) {\n            requiredFeatures |= FEATURE_FEES;\n            _assertFeature(tierFeatures, FEATURE_FEES, tierId, \"FEES_FORBIDDEN\");\n        }\n\n        if (cfg.autoLiquidityEnabled || cfg.autoLiquidityBps > 0) {\n            requiredFeatures |= FEATURE_AUTO_LIQUIDITY;\n            _assertFeature(tierFeatures, FEATURE_AUTO_LIQUIDITY, tierId, \"LIQ_FORBIDDEN\");\n            require(cfg.autoLiquidityRouter != address(0), \"ROUTER_REQ\");\n        } else {\n            require(cfg.autoLiquidityRouter == address(0), \"ROUTER_UNUSED\");\n            require(cfg.autoLiquidityPairToken == address(0), \"PAIR_UNUSED\");\n            require(cfg.autoLiquidityBps == 0, \"BPS_UNUSED\");\n        }\n\n        if (cfg.antiWhaleEnabled || cfg.antiWhale.enabled) {\n            requiredFeatures |= FEATURE_ANTI_WHALE;\n            _assertFeature(tierFeatures, FEATURE_ANTI_WHALE, tierId, \"AW_FORBIDDEN\");\n            require(cfg.antiWhale.maxTxAmount > 0 || cfg.antiWhale.maxWalletAmount > 0, \"AW_PARAMS\");\n        }\n\n        if (cfg.stakingEnabled && cfg.fees.length > 0) {\n            requiredFeatures |= FEATURE_STAKING;\n            _assertFeature(tierFeatures, FEATURE_STAKING, tierId, \"STAKING_FORBIDDEN\");\n            require(cfg.stakingManager != address(0), \"STAKING_MANAGER\");\n        } else {\n            require(cfg.stakingManager == address(0), \"STAKING_UNUSED\");\n        }\n\n        if (hasVesting) {\n            requiredFeatures |= FEATURE_VESTING;\n            _assertFeature(tierFeatures, FEATURE_VESTING, tierId, \"VESTING_FORBIDDEN\");\n            for (uint256 i = 0; i < cfg.initialDistribution.length; i++) {\n                if (cfg.initialDistribution[i].vesting) {\n                    IERC20Template.InitRecipient calldata dist = cfg.initialDistribution[i];\n                    require(dist.duration >= dist.cliff, \"VEST_DURATION\");\n                }\n            }\n        }\n\n        if (cfg.governanceEnabled) {\n            requiredFeatures |= FEATURE_GOVERNANCE;\n            _assertFeature(tierFeatures, FEATURE_GOVERNANCE, tierId, \"GOV_FORBIDDEN\");\n        }\n\n        if (cfg.bridgeOperators.length > 0) {\n            requiredFeatures |= FEATURE_BRIDGE;\n            _assertFeature(tierFeatures, FEATURE_BRIDGE, tierId, \"BRIDGE_FORBIDDEN\");\n        }\n\n        // Supply consistency\n        uint256 liquidityReserve;\n        if (cfg.autoLiquidityEnabled && cfg.autoLiquidityBps > 0) {\n            liquidityReserve = (cfg.initialSupply * cfg.autoLiquidityBps) / BPS_DENOMINATOR;\n        }\n\n        uint256 stakingReserve;\n        if (cfg.stakingEnabled) {\n            for (uint256 i = 0; i < cfg.fees.length; i++) {\n                if (cfg.fees[i].feeType == IERC20Template.FeeType.Staking) {\n                    stakingReserve += (cfg.initialSupply * cfg.fees[i].bps) / BPS_DENOMINATOR;\n                }\n            }\n        }\n\n        require(totalDistribution + liquidityReserve + stakingReserve == cfg.initialSupply, \"SUPPLY_MISMATCH\");\n    }\n\n    function _assertFeature(uint256 tierFeatures, uint256 feature, uint8 tierId, string memory err) private pure {\n        if ((tierFeatures & feature) == 0) {\n            revert(string.concat(err, \"_TIER\"));\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}